{"version":3,"sources":["../../src/JsonModel/makeMigrations.js"],"names":["cloneModelWithDb","m","db","model","Object","create","_set","_makeSetFn","makeMigrations","name","tableName","idCol","columns","migrations","migrationOptions","tableQuoted","sql","quoteId","allMigrations","quoted","type","autoIncrement","keySql","exec","col","entries","expr","replace","real","index","unique","ignoreNull","wrappedMigrations","wrapMigration","migration","wrap","fn","writeableDb","store","__madeWriteable","values","forEach","up","keys","k"],"mappings":"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","sourcesContent":["import {sql} from '../DB'\n\nexport const cloneModelWithDb = (m, db) => {\n\tconst model = Object.create(m)\n\tmodel.db = db\n\tmodel._set = model._makeSetFn()\n\treturn model\n}\n\nexport const makeMigrations = ({\n\tname: tableName,\n\tidCol,\n\tcolumns,\n\tmigrations,\n\tmigrationOptions,\n}) => {\n\tconst tableQuoted = sql.quoteId(tableName)\n\tconst allMigrations = {\n\t\t...migrations,\n\t\t// We make id a real column to allow foreign keys\n\t\t0: ({db}) => {\n\t\t\tconst {quoted, type, autoIncrement} = columns[idCol]\n\t\t\t// The NOT NULL is a SQLite bug, otherwise it allows NULL as id\n\t\t\tconst keySql = `${type} PRIMARY KEY ${\n\t\t\t\tautoIncrement ? 'AUTOINCREMENT' : ''\n\t\t\t} NOT NULL`\n\t\t\treturn db.exec(\n\t\t\t\t`CREATE TABLE ${tableQuoted}(${quoted} ${keySql}, json JSON);`\n\t\t\t)\n\t\t},\n\t}\n\tfor (const [name, col] of Object.entries(columns)) {\n\t\t// We already added these, or it's an alias\n\t\tif (name === idCol || name === 'json' || name !== col.name) continue\n\t\tconst expr = col.sql.replace('tbl.', '')\n\t\t// Make sure real columns are created before indexes on expressions\n\t\tallMigrations[`${col.real ? 0 : 1}_${name}`] = ({db}) =>\n\t\t\tdb.exec(\n\t\t\t\t`${\n\t\t\t\t\tcol.type\n\t\t\t\t\t\t? `ALTER TABLE ${tableQuoted} ADD COLUMN ${col.quoted} ${col.type};`\n\t\t\t\t\t\t: ''\n\t\t\t\t}${\n\t\t\t\t\tcol.index\n\t\t\t\t\t\t? `CREATE ${\n\t\t\t\t\t\t\t\tcol.unique ? 'UNIQUE ' : ''\n\t\t\t\t\t\t  }INDEX IF NOT EXISTS ${sql.quoteId(\n\t\t\t\t\t\t\t\t`${tableName}_${name}`\n\t\t\t\t\t\t  )} ON ${tableQuoted}(${expr}) ${\n\t\t\t\t\t\t\t\tcol.ignoreNull ? `WHERE ${expr} IS NOT NULL` : ''\n\t\t\t\t\t\t  };`\n\t\t\t\t\t\t: ''\n\t\t\t\t}`\n\t\t\t)\n\t}\n\t// Wrap the migration functions to provide their arguments\n\tconst wrappedMigrations = {}\n\tconst wrapMigration = migration => {\n\t\tconst wrap = fn =>\n\t\t\tfn &&\n\t\t\t(writeableDb => {\n\t\t\t\tif (!writeableDb.store.__madeWriteable) {\n\t\t\t\t\tconst {store} = writeableDb\n\t\t\t\t\twriteableDb.store = {__madeWriteable: true}\n\t\t\t\t\t// Create a patched version of all models that uses the migration db\n\t\t\t\t\tObject.values(store).forEach(m => {\n\t\t\t\t\t\tif (typeof m !== 'object') return\n\t\t\t\t\t\twriteableDb.store[m.name] = cloneModelWithDb(m, writeableDb)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tconst model = writeableDb.store[tableName]\n\t\t\t\treturn fn({...migrationOptions, db: writeableDb, model})\n\t\t\t})\n\t\treturn wrap(migration.up || migration)\n\t}\n\tObject.keys(allMigrations).forEach(k => {\n\t\tconst m = allMigrations[k]\n\t\tif (m) wrappedMigrations[k] = wrapMigration(m)\n\t})\n\treturn wrappedMigrations\n}\n"],"file":"makeMigrations.js"}